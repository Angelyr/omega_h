\documentclass{article}

\usepackage{hyperref}
\usepackage{listings}
\lstset{
  basicstyle=\ttfamily,
  columns=fullflexible,
  keepspaces=true,
  numbers=left,
  xleftmargin=2em
}

\title{The Omega\_h Users Manual}
\author{Dan Ibanez\\
Sandia National Laboratories\\
daibane@sandia.gov}

\begin{document}

\maketitle

\section{Obtaining}

Omega\_h is developed and distributed via GitHub,
a popular software hosting platform based on the
Git distributed version control system.

\url{https://github.com/ibaned/omega_h}

The most common way to obtain Omega\_h is to
use Git to clone the repository and automatically
check out the \texttt{master} branch:

\begin{lstlisting}[language=bash]
git clone git@github.com:ibaned/omega_h.git
\end{lstlisting}

\section{Compiling}

\subsection{Operating System}

Omega\_h currently only supports POSIX-like operating systems.
It has only been tested on Linux, Mac OS X, and certain POSIX-like
supercomputer kernels.

\subsection{CMake}

Omega\_h's compilation process is controlled by the CMake
build system.
In order to build Omega\_h, one should install a recent
version of CMake, with version 3.0.1 being the minimum
acceptable version.
CMake is available in most Linux package managers
or from their website:

\url{https://cmake.org/download/}

It is also recommended that users adopt the CMake build
system for their own project, in order to take advantage
of the metadata that Omega\_h outputs when it compiles
and installs, which is readable by other CMake projects.

\subsection{Compiler}

Omega\_h is written in the C++11 standard of C++,
so a compiler with complete support for that standard
is needed.
Omega\_h's CMake files will accept the GCC, Clang,
and Intel compilers, and support can be added
fairly easily for other compilers upon request.

\subsection{Dependencies}

All dependencies of Omega\_h are optional,
meaning that one can compile it by itself and obtain a fairly
functional code for mesh adaptation, although
it will not have parallel features yet.
Optional dependencies of Omega\_h are:

\begin{enumerate}

\item Zlib: This widely used and installed C library implements
efficient data compression algorithms.
Omega\_h uses it compress its own `.osh` file format and
VTK's `.vtu` files.

\item MPI: The Message Passing Interface is a standard
defining (at least) a C library that enables multi-process parallelism.
This is required if you want to use multi-process parallelism
in Omega\_h.
The two good open-source implementations that Omega\_h is known
to work with are MPICH and OpenMPI, and we recommend
MPICH for its support of the latest MPI standard and its
cleaner memory management.

\item Kokkos: This C++11 library implements shared-memory parallelism
constructs and allows Omega\_h to (mostly) not worry about the details
of OpenMP and CUDA.
It is required if you want to use shared-memory parallelism in Omega\_h.
Kokkos can be obtained as part of Trilinos, and Trilinos can be configured
to compile and install only Kokkos.

\item libMeshb: This C library implements the `.mesh` and `.meshb`
file formats used by INRIA, NASA, and others.
It is required to read and write `.meshb` files from Omega\_h.
Note that currently Omega\_h follows a particular convention in what
those files are expected to contain, namely elements, vertices,
and sides on the boundary.

\item EGADS: This C API wraps over OpenCASCADE in a human-manageable way.
It is required if you want Omega\_h to snap new vertices to geometry.
Note that classification in Omega\_h should match the numbering
of geometric entities in EGADS.

\end{enumerate}

Each of these dependencies

\subsection{Options}

\section{Usage}

\subsection{Utility Programs}

\begin{enumerate}
\item \texttt{msh2osh}
\item \texttt{osh2vtk}
\item \texttt{oshdiff}
\item \texttt{vtkdiff}
\item \texttt{osh\_box}
\item \texttt{osh\_part}
\item \texttt{osh\_scale}
\item \texttt{meshb2osh}
\item \texttt{osh2meshb}
\end{enumerate}

\subsection{Header and Library}

In most cases, users should call the C++11 API of Omega\_h directly
from their own C++ code.
In terms of the build system, users need their code to include
the \texttt{Omega\_h.hpp} header file and link their own code
to the \texttt{libomega\_h.so} or \texttt{libomeg\_h.a} library.
In the case of static linking (\texttt{libomega\_h.a}), it is
also necessary to link to the final executable to all libraries
that Omega\_h depends on.
In the case of dynamic linking, \texttt{libomega\_h.so} is guaranteed
to already be linked to its dependencies via the \texttt{RPATH}
mechanism, so only \texttt{libomega\_h.so} needs to be linked
to the user application.

\subsection{Via CMake}

The most convenient way to handle the header file inclusion
and library linking to Omega\_h is to use the CMake build system
for the user's project as well.
Omega\_h uses CMake to export file

\texttt{\$\{CMAKE\_INSTALL\_PREFIX\}/lib/cmake/Omega\_hConfig.cmake}

which provides all the necessary include and link information
to CMake when CMake is configuring the user's project.
The way for the user's project to read that file is via
CMake's \texttt{find\_package} command:

\begin{lstlisting}
find_package(Omega_h 8.2.0 PATHS ${OMEGA_H_PREFIX})
\end{lstlisting}

Only the first argument (``Omega\_h") is really necessary.
The second argument specifies a minimum required version number.
CMake will only accept an Omega\_h installation that has
the same or higher version number, unless the major version number
is higher, because that indicates a change that breaks backwards
compatibility.
The last two arguments can be used to indicate that Omega\_h
is installed somewhere other than the standard system directories
(e.g. \texttt{/usr/local}).
If \texttt{find\_package} succeeds, subsequent CMake code has
access to a target called \texttt{Omega\_h::omega\_h}, which
represents all the information needed to link to Omega\_h,
and is used via \texttt{target\_link\_libraries} with a user's

\subsection{The Omega\_h Namespace}

\section{Read and Write: The Array Classes}

\section{The Mesh: A (Mostly) Immutable Cache}

\end{document}
